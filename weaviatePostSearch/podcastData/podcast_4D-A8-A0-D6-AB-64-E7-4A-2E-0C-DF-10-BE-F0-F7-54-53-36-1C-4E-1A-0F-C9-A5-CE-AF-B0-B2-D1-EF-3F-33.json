{
    "Id": "4D-A8-A0-D6-AB-64-E7-4A-2E-0C-DF-10-BE-F0-F7-54-53-36-1C-4E-1A-0F-C9-A5-CE-AF-B0-B2-D1-EF-3F-33",
    "ContentSourceId": "f8b5d0b7-9181-43a4-8fab-d3e2b2c93d0a",
    "Title": "Episode 59: Static Code Analysis",
    "SourceUrl": "http://feedproxy.google.com/~r/se-radio/~3/MbCk_toaIMs/",
    "Description": "This episode is a discussion with Jonathan Aldrich (Assistant Professor at CMU) about static analysis. The discussion covered theory as well as practice and tools. We started with an explanation of what static analysis actually is, which kinds of errors it can find and how it is different from testing and reviews. The core challenge of such an analysis tool is to understand the semantics of the program and reduce its possible state space to make it analysable - in effect reconstructing the programmer's intent from the code. The user can \"help\" the tool with this challenge by using suitable annotations; also, languages could do a better job of being analysable. The conceptual discussion was concluded by looking at the principles of static analysis (termination, soundness. precision) and how this approach relates to model analysis. \n\nThe second more practical part started out with a discussion of how Microsoft successfully uses static analysis in their Windows development. We then discussed some of the tools available; these include Findbugs, Coverity, Codesonar, Clockwork, Fortify, Polyspace and Codesurfer. To conclude the discussion of tools, we discussed the commonalities and differences with architecture visualization tools as well as metrics and heuristics. \n\nPart three of the discussion briefly looked at how to introduce static analysis tools into an organization's development process and tool chain. We concluded the discussion by looking at situations where static analysis does not work, as well as at the FLUID research project at CMU.",
    "EnclosureUrl": "https://traffic.libsyn.com/secure/seradio/seradio-episode59-StaticCodeAnalysis.mp3?dest-id=23379"
}